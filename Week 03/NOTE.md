# 学习笔记

# 编译原理相关

本周的学习内容是和编译原理相关的，所以先学习了下编译原理相关的简单知识，有一个基本的概念。

## 编译器

程序设计语言是向人以及计算机描述计算过程的记号，如我们所知，这个世界依赖于程序设计语言，因为在所有计算机上运行的所有软件都是在用某种程序设计语言编写的。但是，在一个程序可以运行之前，它首先需要被编译成一种能够被计算机执行的形式。完成这项翻译工作的软件系统称之为编译器。

## 一个编译器的各个步骤

字符流 ==> [词法分析器] ==> 符号流 ==> [语法分析] ==> 语法树 ==> [语义分析] ==> 语法树 ==> [中间代码生成器] ==> 中间表示形式 ==> [及其无关代码优化器] ==> 中间表示形式 ==> [代码生成器] ==> 目标机器语言 ==> [机器相关代码优化器] ==> 目标机器语言

</br>
对于一个语句的翻译简单流程示意如下：</br>

![示意图](https://gitee.com/loveBean001/PlistShangChuan/raw/master/编译原理示意图.png)

# AST
从上面编译流程示意图来看，AST其实是语法分析后的产物</br>
[参考文档](https://blog.csdn.net/weixin_39408343/article/details/95984062)

## 什么是 AST

抽象语法树 (abstract syntax Tree)是是一种分层的程序表示，它根据编程语言的语法来表示源代码结构，每个 AST 节点对应一个源代码项（It is a hierarchical program representation that presents source code structure according to the grammar of a programming language, each AST node corresponds to an item of a source code.）。

## 为什么是抽象的？

这就要说抽象语法树的两个特点
抽象语法树的第一个特点为:不依赖于具体的文法。无论是 LL(1)文法，还是 LR(1)，或者还是其它的方法，都要求在语法分析时候，构造出相同的语法树，这样可以给编译器后端提供了清晰，统一的接口。即使是前端采用了不同的文法，都只需要改变前端代码，而不用连累到后端。即减少了工作量，也提高的编译器的可维护性。
抽象语法树的第二个特点为:不依赖于语言的细节。在编译器家族中，大名鼎鼎的 gcc 算得上是一个老大哥了，它可以编译多种语言，例如 c，c ＋＋，java，ADA，Object C， FORTRAN， PASCAL， COBOL 等等。在前端 gcc 对不同的语言进行词法，语法分析和语义分析后，产生抽象语法树形成中间代码作为输出，供后端处理。要做到这一点，就必须在构造语法树时，不依赖于语言的细节。
与抽象相对的，CST(Concrete Syntax Tree-具体语法树)

## AST 在 JS 中的应用举例

### 1. babel
   babel 是一个 JavaScript 编译器。宏观来说，它分 3 个阶段运行代码：解析(parsing) — 将代码字符串转换成 AST 抽象语法树，转译(transforming) — 对抽象语法树进行变换操作，生成(generation) — 根据变换后的抽象语法树生成新的代码字符串。
   我们给 babel 一段 js 代码，它修改代码然后生成新的代码返回。它是怎么修改代码的呢？没错，它创建了 AST，遍历树，修改 tokens，最后从 AST 中生成新的代码。
### 2. vue、react 之类前端框架
   比如 winter 老师小课讲过手撸一个 React，其中很重要的一步是需要下载 babel 和他的一个插件--(@babel/plugin-transform-react-jsx),可以将标签转换为createElement()函数。</br>
   总之通过 解析->转译->生成 散步操作，JS 上很多黑魔法一样的东西就产生了。


# LL 文法
通过本周的编程练习，模糊理解了LL文法从左到右扫描和从左到右归约的意思。整体还是比较茫然的

# 总结
本周的编程训练，对我这个非计算机专业的开发者来说，算是开启了编译原理相关知识的大门，本周我也去大概了解了下编译原理相关的知识。虽然很模糊，但是对个人知识体系和见识上来说，提升了一个思考的高度。
从编程训练的角度来说，我觉得语法分析的相关代码很好的体现了递归分治的思想，对提升递归相关的Code能力还是比较有帮助的。

