# 浏览器工作原理每课老师总结
URL===[HTTP]====>HTML   
===[parse]====>DOM  
===[css computing]====>Dom with CSS  
===[layout]====>Dom with position  
===[render]====>BitMap  

## HTML解析

### 将文本节点加到DOM树
1. 文本节点于自封闭标签处理类似。
2. 多个文本节点需要合并。

## CSS计算

### 收集CSS规则
1. 遇到style标签时，把CSS规则保存起来
2. 使用npm现成的css包来做css规则的parser
3. 必须仔细研究css库分析规则的格式，为后续做准备

### 添加调用
1. 计算CSS的时机--当创建一个元素后，立即计算CSS
2. 理论上，当我们分析一个元素时，所有CSS规则已经收集完毕。
3. 在真实浏览器中可能遇到写在body的style标签，需要重新计算CSS的情况，Toy中忽略这个情况

### 获取父元素序列
1. 在computeCSS函数中，我们必须知道元素的所有父元素才能判断元素与规则是否匹配
2. 我们从上一步骤的stack，可以获取本元素的所有父元素
3. 因为我们首先获取的是“ 当前元素”，所以我们获得和计算父元素匹配的顺序是从内向外的

### 选择器与父元素的匹配
1. 选择器也要从当前元素向外排列
2. 复杂选择器拆分成针对单个元素的选择器，用循环匹配父元素队列   

### 计算选择器与父元素的匹配
1. 根据选择器的类型和元素属性，计算是否与当前元素匹配
2. 这里仅实现了三种基本选择器，实际的浏览器要处理复合选择器。

### 生成computed属性
1. 一旦选择匹配，就应用选择器到元素上，形成computedStyle

### specificity的计算逻辑
优先级四元组,根据选择器组来生成优先级四元组，高位有效则不考虑低位
[(cnt){inline}, (cnt){id}, (cnt){class}, (cnt){tag}]

1. CSS规则根据specificity和后来优先规则覆盖
2. specificity是个四元组，越左边权重越高
3. 一个CSS规则的specificity根据包含的简单选择器相加而成

## 排版计算-Layout
### 根据浏览器属性进行排版
### 收集元素进行(Line)
#### 分行
1. 根据主轴尺寸，把元素分进行
2. 若设置了no-wrap, 则强行分配进第一行

### 计算主轴方向
1. 找出所有Flex元素
2. 把主轴方向的剩余尺寸按比例分配给这些元素
3. 如果剩余空间为负数，所有flex元素为0，等比压缩剩余元素

### 计算交叉轴
1. 根据每一行中最大元素尺寸计算行高
2. 根据行高flex-align 和 item-align，确定元素具体位置
